import { MendixMicroflow, MicroflowNode, GeneratedFile } from '../types'

function generateNodeStatement(node: MicroflowNode, indent: string): string {
  switch (node.kind) {
    case 'CreateObjectAction':
      return `${indent}const new${node.entityName || 'Object'} = await prisma.${(node.entityName || 'entity').toLowerCase()}.create({ data: {} })`

    case 'RetrieveAction':
      return `${indent}const ${(node.entityName || 'items').toLowerCase()}List = await prisma.${(node.entityName || 'entity').toLowerCase()}.findMany()`

    case 'ChangeObjectAction':
      return `${indent}await prisma.${(node.entityName || 'entity').toLowerCase()}.update({ where: { id: 0 /* TODO */ }, data: { /* TODO */ } })`

    case 'DeleteAction':
      return `${indent}await prisma.${(node.entityName || 'entity').toLowerCase()}.delete({ where: { id: 0 /* TODO */ } })`

    case 'MicroflowCallAction':
      return `${indent}await ${node.targetMicroflow || 'unknownMicroflow'}(/* TODO: params */)`

    case 'LogMessageAction':
      return `${indent}console.log(${node.message ? JSON.stringify(node.message) : '"TODO: log message"'})`

    case 'ExclusiveSplit':
      return `${indent}if (/* TODO: ${node.expression || 'condition'} */) {\n${indent}  // true branch\n${indent}} else {\n${indent}  // false branch\n${indent}}`

    case 'LoopedActivity':
      return `${indent}for (const item of items) {\n${indent}  // TODO: loop body\n${indent}}`

    case 'EndEvent':
      return node.expression
        ? `${indent}return /* TODO: ${node.expression} */`
        : `${indent}return`

    case 'StartEvent':
      return ''  // nothing to emit

    default:
      return `${indent}// TODO: ${node.rawType}`
  }
}

function generateMicroflowFunction(mf: MendixMicroflow): string {
  const params = mf.parameters.map(p => `${p.name}: any`).join(', ')
  const returnType = mf.returnType ? ': Promise<any>' : ': Promise<void>'

  const statements: string[] = []

  // Generate statements for each non-start node
  for (const node of mf.nodes) {
    if (node.kind === 'StartEvent') continue
    const stmt = generateNodeStatement(node, '  ')
    if (stmt) statements.push(stmt)
  }

  if (statements.length === 0) {
    statements.push('  // TODO: implement microflow logic')
  }

  return `export async function ${mf.name}(${params})${returnType} {
${statements.join('\n')}
}`
}

export function generateMicroflowServices(microflows: MendixMicroflow[]): GeneratedFile[] {
  const MAX_MICROFLOWS = 50
  const limited = microflows.slice(0, MAX_MICROFLOWS)

  if (microflows.length > MAX_MICROFLOWS) {
    console.warn(`[microflowGenerator] Capped at ${MAX_MICROFLOWS} microflows (${microflows.length} total)`)
  }

  return limited.map(mf => {
    const header = `// Generated by mendix-to-node
// Microflow: ${mf.qualifiedName}
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()
`
    return {
      path: `src/services/${mf.name}.ts`,
      content: header + '\n' + generateMicroflowFunction(mf) + '\n',
      category: 'logic' as const
    }
  })
}
