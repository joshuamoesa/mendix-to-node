import { MendixPage, MendixWidget, GeneratedFile } from '../types'

function widgetToHtml(widget: MendixWidget, indent: string, routePath: string = ''): string {
  const i = indent
  const i2 = indent + '  '

  switch (widget.kind) {
    case 'DataView': {
      const formEntity = widget.entityName || 'entity'
      const children = widget.children.map(c => widgetToHtml(c, i2, routePath)).filter(Boolean).join('\n')
      const actionPath = routePath || formEntity.toLowerCase()
      return `${i}<form method="POST" action="/${actionPath}/save">
${i2}<h2>${widget.caption || formEntity}</h2>
${children || `${i2}<!-- TODO: form fields -->`}
${i2}<button type="submit" class="btn">Save</button>
${i}</form>`
    }

    case 'ListView':
    case 'DataGrid': {
      const entity = widget.entityName || 'items'
      const entityVar = entity.toLowerCase()
      return `${i}<table class="table">
${i2}<thead><tr><th>${entity}</th><th>Actions</th></tr></thead>
${i2}<tbody>
${i2}  <% ${entityVar}List.forEach(function(item) { %>
${i2}  <tr>
${i2}    <td><%= item.id %></td>
${i2}    <td><a href="/${entityVar}/<%= item.id %>">View</a></td>
${i2}  </tr>
${i2}  <% }) %>
${i2}</tbody>
${i}</table>`
    }

    case 'TextBox': {
      const attr = widget.attributeName || 'field'
      return `${i}<div class="form-group">
${i2}<label for="${attr}">${widget.caption || attr}</label>
${i2}<input type="text" id="${attr}" name="${attr}" value="<%= item && item.${attr} ? item.${attr} : '' %>" class="form-control">
${i}</div>`
    }

    case 'TextArea': {
      const attr = widget.attributeName || 'field'
      return `${i}<div class="form-group">
${i2}<label for="${attr}">${widget.caption || attr}</label>
${i2}<textarea id="${attr}" name="${attr}" class="form-control"><%= item && item.${attr} ? item.${attr} : '' %></textarea>
${i}</div>`
    }

    case 'Button': {
      if (widget.microflowName) {
        return `${i}<button type="button" formaction="/services/${widget.microflowName}" class="btn">${widget.caption || 'Action'}</button>`
      }
      return `${i}<button type="submit" class="btn">${widget.caption || 'Submit'}</button>`
    }

    case 'Label':
    case 'Text':
      return `${i}<p>${widget.caption || ''}</p>`

    case 'Container': {
      const children = widget.children.map(c => widgetToHtml(c, i2, routePath)).filter(Boolean).join('\n')
      return children ? `${i}<div>\n${children}\n${i}</div>` : ''
    }

    default:
      return widget.children.length > 0
        ? widget.children.map(c => widgetToHtml(c, i, routePath)).filter(Boolean).join('\n')
        : `${i}<!-- ${widget.rawType} -->`
  }
}

function generateEjsTemplate(page: MendixPage): string {
  const title = page.title || page.name
  const routePath = page.name.toLowerCase()
  const widgetHtml = page.widgets.map(w => widgetToHtml(w, '  ', routePath)).filter(Boolean).join('\n\n')

  return `<div class="container">
  <h1>${title}</h1>

${widgetHtml || '  <!-- TODO: page content -->'}
</div>`
}

function generateRouteFile(page: MendixPage): string {
  const routePath = page.name.toLowerCase()
  const entity = (page.entityName || 'item').toLowerCase()

  return `// Generated by mendix-to-node
// Route for page: ${page.qualifiedName}
import { Router, Request, Response } from 'express'
import { prisma } from '../db'

const router = Router()

// GET /${routePath} - render page
router.get('/${routePath}', async (req: Request, res: Response) => {
  try {
    const ${entity}List = await prisma.${entity}.findMany()
    res.render('${page.name}', { title: '${page.title || page.name}', ${entity}List })
  } catch (err) {
    res.status(500).render('error', { title: 'Error', message: 'Failed to load ${page.name}' })
  }
})

// POST /${routePath}/save - handle form submit
router.post('/${routePath}/save', async (req: Request, res: Response) => {
  try {
    const data = req.body
    await prisma.${entity}.create({ data })
    res.redirect('/${routePath}')
  } catch (err) {
    res.status(500).render('error', { title: 'Error', message: 'Failed to save' })
  }
})

export default router
`
}

export function generatePages(pages: MendixPage[]): GeneratedFile[] {
  const MAX_PAGES = 30
  const limited = pages.slice(0, MAX_PAGES)

  if (pages.length > MAX_PAGES) {
    console.warn(`[pageGenerator] Capped at ${MAX_PAGES} pages (${pages.length} total)`)
  }

  const files: GeneratedFile[] = []

  for (const page of limited) {
    files.push({
      path: `views/${page.name}.ejs`,
      content: generateEjsTemplate(page),
      category: 'pages'
    })

    files.push({
      path: `src/routes/${page.name}.ts`,
      content: generateRouteFile(page),
      category: 'routes'
    })
  }

  // Always generate a minimal error view used by route error handlers
  files.push({
    path: 'views/error.ejs',
    content: `<div class="container">
  <h1>Error</h1>
  <p style="color:#c0392b;margin:1rem 0"><%= message %></p>
  <a href="/" class="btn">Back</a>
</div>`,
    category: 'pages'
  })

  return files
}

export function generateEntityRoutes(entities: Array<{ name: string }>): GeneratedFile[] {
  return entities.filter(e => e.name).map(entity => {
    const name = entity.name
    const nameLower = name.toLowerCase()

    const content = `// Generated by mendix-to-node
// CRUD routes for entity: ${name}
import { Router, Request, Response } from 'express'
import { prisma } from '../db'

const router = Router()

// GET /${nameLower} - list all
router.get('/${nameLower}', async (req: Request, res: Response) => {
  try {
    const items = await prisma.${nameLower}.findMany()
    res.json(items)
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch ${name} records' })
  }
})

// GET /${nameLower}/:id - get one
router.get('/${nameLower}/:id', async (req: Request, res: Response) => {
  try {
    const item = await prisma.${nameLower}.findUnique({ where: { id: parseInt(req.params.id) } })
    if (!item) return res.status(404).json({ error: 'Not found' })
    res.json(item)
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch ${name}' })
  }
})

// POST /${nameLower} - create
router.post('/${nameLower}', async (req: Request, res: Response) => {
  try {
    const item = await prisma.${nameLower}.create({ data: req.body })
    res.status(201).json(item)
  } catch (err) {
    res.status(500).json({ error: 'Failed to create ${name}' })
  }
})

// PUT /${nameLower}/:id - update
router.put('/${nameLower}/:id', async (req: Request, res: Response) => {
  try {
    const item = await prisma.${nameLower}.update({
      where: { id: parseInt(req.params.id) },
      data: req.body
    })
    res.json(item)
  } catch (err) {
    res.status(500).json({ error: 'Failed to update ${name}' })
  }
})

// DELETE /${nameLower}/:id - delete
router.delete('/${nameLower}/:id', async (req: Request, res: Response) => {
  try {
    await prisma.${nameLower}.delete({ where: { id: parseInt(req.params.id) } })
    res.status(204).send()
  } catch (err) {
    res.status(500).json({ error: 'Failed to delete ${name}' })
  }
})

export default router
`

    return {
      path: `src/routes/${nameLower}.ts`,
      content,
      category: 'routes' as const
    }
  })
}
